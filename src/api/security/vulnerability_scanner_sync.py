"""
Synchronous vulnerability scanner for Celery tasks

This module provides a synchronous version of the vulnerability scanner specifically
designed for use in Celery tasks to avoid asyncio.run() performance issues.
"""

import logging
import os
import re
import time
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import httpx
from cachetools import TTLCache
import json

from ..models import DependencyInfo
from ..utils.exceptions import (
    ExternalServiceError, 
    VulnerabilityServiceError,
    RateLimitError,
    ConfigurationError
)
from .dependency_parser import ParsedDependency, PackageEcosystem
from .vulnerability_scanner import VulnerabilitySeverity, VulnerabilityMatch

logger = logging.getLogger(__name__)


class SyncNVDAPIClient:
    """
    Synchronous NVD (National Vulnerability Database) API client for Celery tasks
    """
    
    def __init__(
        self,
        api_key: Optional[str] = None,
        base_url: str = "https://services.nvd.nist.gov/rest/json",
        timeout: float = 30.0,
        rate_limit_delay: float = 2.0,
        cache_ttl: int = 3600  # 1 hour
    ):
        """
        Initialize synchronous NVD API client
        
        Args:
            api_key: NVD API key for higher rate limits
            base_url: NVD API base URL
            timeout: Request timeout
            rate_limit_delay: Delay between requests (seconds)
            cache_ttl: Cache time-to-live in seconds
        """
        self.api_key = api_key or os.getenv("NVD_API_KEY")
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.rate_limit_delay = rate_limit_delay
        
        # Setup client
        self.client = httpx.Client()
        headers = {
            "User-Agent": "Caponier-Security-Scanner/1.0",
            "Accept": "application/json"
        }
        
        if self.api_key:
            headers["apiKey"] = self.api_key
            self.rate_limit_delay = 0.6  # Higher rate limit with API key
            logger.info("NVD client initialized with API key")
        else:
            logger.warning("NVD client initialized without API key - rate limits will be lower")
        
        self.client.headers.update(headers)
        
        # Response cache
        self.cache = TTLCache(maxsize=10000, ttl=cache_ttl)
        
        # Rate limiting
        self.last_request_time = 0
        
        # Statistics
        self.stats = {
            "requests_made": 0,
            "cache_hits": 0,
            "rate_limit_hits": 0,
            "errors": 0
        }
    
    def close(self):
        """Close the client"""
        if self.client:
            self.client.close()
    
    def _rate_limit(self):
        """Enforce rate limiting"""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        
        if time_since_last < self.rate_limit_delay:
            sleep_time = self.rate_limit_delay - time_since_last
            logger.debug(f"Rate limiting: sleeping {sleep_time:.2f}s")
            time.sleep(sleep_time)
            self.stats["rate_limit_hits"] += 1
        
        self.last_request_time = time.time()
    
    def search_cves(
        self,
        keyword: Optional[str] = None,
        cpe_name: Optional[str] = None,
        cve_id: Optional[str] = None,
        cvss_v3_severity: Optional[str] = None,
        results_per_page: int = 20,
        start_index: int = 0
    ) -> Dict[str, Any]:
        """
        Search for CVEs using NVD API
        
        Args:
            keyword: Keyword to search for
            cpe_name: CPE name to search for
            cve_id: Specific CVE ID to lookup
            cvss_v3_severity: CVSS v3 severity filter
            results_per_page: Number of results per page
            start_index: Starting index for pagination
            
        Returns:
            NVD API response data
        """
        # Check cache first
        cache_key = self._get_cache_key(keyword, cpe_name, cve_id, cvss_v3_severity, results_per_page, start_index)
        if cache_key in self.cache:
            self.stats["cache_hits"] += 1
            logger.debug(f"Cache hit for CVE search: {cache_key}")
            return self.cache[cache_key]
        
        # Rate limiting
        self._rate_limit()
        
        # Build query parameters
        params = {
            "resultsPerPage": results_per_page,
            "startIndex": start_index
        }
        
        if keyword:
            params["keywordSearch"] = keyword
        if cpe_name:
            params["cpeName"] = cpe_name
        if cve_id:
            params["cveId"] = cve_id
        if cvss_v3_severity:
            params["cvssV3Severity"] = cvss_v3_severity
        
        try:
            self.stats["requests_made"] += 1
            
            url = f"{self.base_url}/cves/2.0"
            response = self.client.get(url, params=params, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                
                # Cache the response
                self.cache[cache_key] = data
                
                logger.debug(f"NVD API request successful: {len(data.get('vulnerabilities', []))} results")
                return data
            
            elif response.status_code == 403:
                raise RateLimitError("NVD API rate limit exceeded")
            
            elif response.status_code == 404:
                # No results found - return empty response
                empty_response = {
                    "vulnerabilities": [],
                    "totalResults": 0,
                    "resultsPerPage": results_per_page,
                    "startIndex": start_index
                }
                self.cache[cache_key] = empty_response
                return empty_response
            
            else:
                raise VulnerabilityServiceError(
                    f"NVD API error: HTTP {response.status_code}",
                    "nvd_api"
                )
                
        except httpx.RequestError as e:
            self.stats["errors"] += 1
            logger.error(f"NVD API request failed: {e}")
            raise ExternalServiceError(f"NVD API request failed: {str(e)}", "nvd_api")
    
    def _get_cache_key(self, *args) -> str:
        """Generate cache key from arguments"""
        return "|".join(str(arg) if arg is not None else "" for arg in args)
    
    def get_stats(self) -> Dict[str, Any]:
        """Get client statistics"""
        return {
            **self.stats,
            "has_api_key": bool(self.api_key),
            "cache_size": len(self.cache)
        }


class SyncVulnerabilityScanner:
    """
    Synchronous vulnerability scanner for Celery tasks
    """
    
    def __init__(self, nvd_client: Optional[SyncNVDAPIClient] = None):
        """
        Initialize synchronous vulnerability scanner
        
        Args:
            nvd_client: Optional synchronous NVD API client
        """
        self.nvd_client = nvd_client or SyncNVDAPIClient()
        
        # Package ecosystem to CPE vendor mappings
        self.ecosystem_vendors = {
            PackageEcosystem.NPM: "nodejs",
            PackageEcosystem.PIP: "python",
            PackageEcosystem.CARGO: "rust-lang",
            PackageEcosystem.MAVEN: "apache",
            PackageEcosystem.GRADLE: "gradle"
        }
    
    def close(self):
        """Close the NVD client"""
        if self.nvd_client:
            self.nvd_client.close()
    
    def scan_dependencies(
        self,
        dependencies: List[ParsedDependency],
        severity_filter: Optional[Set[VulnerabilitySeverity]] = None,
        include_low_confidence: bool = False
    ) -> List[VulnerabilityMatch]:
        """
        Scan list of dependencies for vulnerabilities
        
        Args:
            dependencies: List of parsed dependencies
            severity_filter: Only include vulnerabilities of these severities
            include_low_confidence: Include low-confidence matches
            
        Returns:
            List of vulnerability matches
        """
        # Default to Critical and High severity only
        if severity_filter is None:
            severity_filter = {VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH}
        
        vulnerability_matches = []
        
        # Process dependencies one by one with rate limiting
        for i, dependency in enumerate(dependencies):
            try:
                logger.debug(f"Scanning dependency {i+1}/{len(dependencies)}: {dependency.name}")
                
                matches = self._scan_single_dependency(dependency, severity_filter, include_low_confidence)
                if matches:
                    vulnerability_matches.extend(matches)
                
                # Small delay between scans to respect rate limits
                if i < len(dependencies) - 1:
                    time.sleep(0.5)
                    
            except Exception as e:
                logger.error(f"Error scanning dependency {dependency.name}: {str(e)}")
                continue
        
        logger.info(f"Vulnerability scan completed: {len(vulnerability_matches)} matches found")
        return vulnerability_matches
    
    def _scan_single_dependency(
        self,
        dependency: ParsedDependency,
        severity_filter: Set[VulnerabilitySeverity],
        include_low_confidence: bool
    ) -> List[VulnerabilityMatch]:
        """
        Scan a single dependency for vulnerabilities
        
        Args:
            dependency: Dependency to scan
            severity_filter: Severity filter
            include_low_confidence: Include low confidence matches
            
        Returns:
            List of vulnerability matches
        """
        matches = []
        
        try:
            # Search for vulnerabilities using different strategies
            search_strategies = [
                ("keyword", dependency.name),
                ("cpe", self._build_cpe_name(dependency))
            ]
            
            for strategy, search_term in search_strategies:
                if not search_term:
                    continue
                
                logger.debug(f"Searching vulnerabilities for {dependency.name} using {strategy}: {search_term}")
                
                try:
                    if strategy == "keyword":
                        results = self.nvd_client.search_cves(keyword=search_term, results_per_page=50)
                    else:  # cpe
                        results = self.nvd_client.search_cves(cpe_name=search_term, results_per_page=50)
                    
                    vulnerabilities = results.get("vulnerabilities", [])
                    
                    for vuln_data in vulnerabilities:
                        match = self._process_vulnerability(dependency, vuln_data, strategy)
                        if match and self._passes_filters(match, severity_filter, include_low_confidence):
                            matches.append(match)
                    
                    # If we found matches with the first strategy, don't try others
                    if matches:
                        break
                        
                except Exception as e:
                    logger.warning(f"Search strategy {strategy} failed for {dependency.name}: {e}")
                    continue
            
        except Exception as e:
            logger.error(f"Failed to scan dependency {dependency.name}: {e}")
        
        return matches
    
    def _build_cpe_name(self, dependency: ParsedDependency) -> Optional[str]:
        """
        Build CPE name for dependency
        
        Args:
            dependency: Dependency to build CPE for
            
        Returns:
            CPE name or None if cannot build
        """
        try:
            vendor = self.ecosystem_vendors.get(dependency.ecosystem)
            if not vendor:
                return None
            
            # CPE 2.3 format: cpe:2.3:a:vendor:product:version:*:*:*:*:*:*:*
            cpe_name = f"cpe:2.3:a:{vendor}:{dependency.name.lower()}:{dependency.version}:*:*:*:*:*:*:*"
            return cpe_name
            
        except Exception as e:
            logger.debug(f"Could not build CPE for {dependency.name}: {e}")
            return None
    
    def _process_vulnerability(
        self,
        dependency: ParsedDependency,
        vuln_data: Dict[str, Any],
        match_method: str
    ) -> Optional[VulnerabilityMatch]:
        """
        Process vulnerability data into a match
        
        Args:
            dependency: The dependency being scanned
            vuln_data: Vulnerability data from NVD
            match_method: How the match was found
            
        Returns:
            VulnerabilityMatch or None if not applicable
        """
        try:
            cve = vuln_data.get("cve", {})
            cve_id = cve.get("id", "")
            
            if not cve_id:
                return None
            
            # Calculate confidence score based on match method and name similarity
            confidence = self._calculate_confidence(dependency, cve, match_method)
            
            if confidence < 0.3:  # Minimum confidence threshold
                return None
            
            # Extract affected and patched versions (simplified)
            affected_versions = []
            patched_versions = []
            
            # Create vulnerability data object (simplified)
            from ..models import VulnerabilityData, SeverityLevel
            
            # Extract CVSS score and severity
            cvss_score = None
            severity = SeverityLevel.UNKNOWN
            
            metrics = cve.get("metrics", {})
            if "cvssMetricV3" in metrics:
                cvss_v3 = metrics["cvssMetricV3"][0]["cvssData"]
                cvss_score = cvss_v3.get("baseScore", 0.0)
                severity = self._cvss_to_severity(cvss_score)
            elif "cvssMetricV2" in metrics:
                cvss_v2 = metrics["cvssMetricV2"][0]["cvssData"]
                cvss_score = cvss_v2.get("baseScore", 0.0)
                severity = self._cvss_to_severity(cvss_score)
            
            # Extract description
            descriptions = cve.get("descriptions", [])
            description = ""
            for desc in descriptions:
                if desc.get("lang") == "en":
                    description = desc.get("value", "")
                    break
            
            vulnerability_data = VulnerabilityData(
                cve_id=cve_id,
                package_name=dependency.name,
                package_version=dependency.version,
                severity=severity,
                description=description,
                cve_url=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                cvss_score=cvss_score,
                published_date=self._parse_nvd_date(cve.get("published")),
                last_modified=self._parse_nvd_date(cve.get("lastModified"))
            )
            
            return VulnerabilityMatch(
                cve_id=cve_id,
                package_name=dependency.name,
                package_version=dependency.version,
                vulnerability_data=vulnerability_data,
                confidence_score=confidence,
                match_method=match_method,
                affected_versions=affected_versions,
                patched_versions=patched_versions
            )
            
        except Exception as e:
            logger.warning(f"Failed to process vulnerability {vuln_data}: {e}")
            return None
    
    def _calculate_confidence(self, dependency: ParsedDependency, cve: Dict[str, Any], match_method: str) -> float:
        """Calculate confidence score for a vulnerability match"""
        base_confidence = 0.5 if match_method == "keyword" else 0.8
        
        # Check if package name appears in CVE description
        descriptions = cve.get("descriptions", [])
        for desc in descriptions:
            if desc.get("lang") == "en":
                desc_text = desc.get("value", "").lower()
                if dependency.name.lower() in desc_text:
                    base_confidence += 0.3
                break
        
        return min(base_confidence, 1.0)
    
    def _cvss_to_severity(self, cvss_score: float) -> 'SeverityLevel':
        """Convert CVSS score to severity level"""
        try:
            from ..models import SeverityLevel
        except ImportError:
            # Fallback for circular import issues
            class SeverityLevel:
                CRITICAL = "CRITICAL"
                HIGH = "HIGH"
                MEDIUM = "MEDIUM"
                LOW = "LOW"
                UNKNOWN = "UNKNOWN"
        
        if cvss_score >= 9.0:
            return SeverityLevel.CRITICAL
        elif cvss_score >= 7.0:
            return SeverityLevel.HIGH
        elif cvss_score >= 4.0:
            return SeverityLevel.MEDIUM
        elif cvss_score > 0.0:
            return SeverityLevel.LOW
        else:
            return SeverityLevel.UNKNOWN
    
    def _parse_nvd_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse NVD date string"""
        if not date_str:
            return None
        
        try:
            return datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        except (ValueError, AttributeError):
            return None
    
    def _passes_filters(
        self,
        match: VulnerabilityMatch,
        severity_filter: Set[VulnerabilitySeverity],
        include_low_confidence: bool
    ) -> bool:
        """Check if vulnerability match passes filters"""
        # Check confidence threshold
        if not include_low_confidence and match.confidence_score < 0.7:
            return False
        
        # Check severity filter
        if hasattr(match.vulnerability_data, 'severity'):
            vuln_severity = self._severity_to_vuln_severity(match.vulnerability_data.severity)
            if vuln_severity not in severity_filter:
                return False
        
        return True
    
    def _severity_to_vuln_severity(self, severity) -> VulnerabilitySeverity:
        """Convert model severity to vulnerability severity"""
        from ..models import SeverityLevel
        
        mapping = {
            SeverityLevel.CRITICAL: VulnerabilitySeverity.CRITICAL,
            SeverityLevel.HIGH: VulnerabilitySeverity.HIGH,
            SeverityLevel.MEDIUM: VulnerabilitySeverity.MEDIUM,
            SeverityLevel.LOW: VulnerabilitySeverity.LOW,
            SeverityLevel.UNKNOWN: VulnerabilitySeverity.UNKNOWN
        }
        
        return mapping.get(severity, VulnerabilitySeverity.UNKNOWN)
